BinderMaker
====================

Ploxy


なぜ C言語の API をベースにするのか？(swig のように C++ から生成しないのか？)
--------------------
- それぞれ、clang の libClang と libTooling のような区切りの意味を持っている。つまり、C_API は比較的安定したインターフェイスを提供するのがねらい。
- バインダインターフェイスを作るための属性 (LN_INSTANCE_API や LN_OUT など) は、ソースコードに直接書きたい。(別ファイルに分けてメンテナンスすると同期忘れする)
	- 直接書きたいが、ただでさえ複雑になりがちな C++ ソースには書きたくない。


なぜ swig を使わないのか？
--------------------
- C++ ではなく C API からバインダを作りたい。
- インターフェイスファイルにエクスポートしたい関数を書く必要がある。Lumino の C_API は C++ の超簡単なラッパーなので、.h がそのままエクスポート関数リストにできる。
- コメントは自分で解析する必要がある。結局簡単な .h の解析は自分で行わなければならない。(Altseed は doxygen から xml 作って、swig の生成したメソッドにマッチングさせていた)
- HSP 対応してない。


参照カウントの管理について
--------------------
COM のように、クライアントがポインタを得るような場合はカウントを増やしておく。つまり、C/HSP では Get したら必ず Release をユーザーに義務付ける。

例えば LNSprite_GetTexture() でテクスチャを返すとき、参照カウントを増やさない (ユーザーが Release しなくてすむ) ようにする場合、
内部的にこのハンドルの参照を持っている人がいなければならない。
例えば LNWI_Sprite のメンバ変数に持っておき、LNWI_Sprite インスタンスが消えたらメンバに持っている LNTexture も Release する。もちろん手間。
プロパティならまだ変数1つ追加するだけでよいが、例えばハンドルを返す Find といった関数はどうするのか？

### LNHandle の out 全てを、一度メンバに持つようにしたらどうか？
そうすれば Release をユーザーに義務付ける必要は無くなる。
・・・のだが、LNWI_Sprite とかはいいけど List のように、C++ 側でインスタンスが作れるものは LNWI クラスを定義できない。



クラスライブラリの共通方針
--------------------
### オブジェクト管理

#### 一度作成されたラッパーインスタンスは、Binder 側のグローバルな map で管理する
例えば次のような場合。
```
// C#
t1 = sprite.Texture;
t2 = sprite.Texture;
```
t1 と t2 は同じオブジェクトでなければならない。

グローバルな map はウィークポインタ(ウィークリファレンス)の map でなければならない。
そうしないと、定期的に明示的なGCのようなことを行わなければならない。

#### 参照カウントの管理はラッパーインスタンスが行う
ラッパーインスタンスが生きている間は、C++インスタンスは必ず生きていなければならない。
C++インスタンスからの参照カウント管理は、言語によるかもしれないが基本的に不可能。

ラッパーインスタンスは、例えばC#ではファイナライザなどで参照カウントをデクリメントする。

ラッパーインスタンスとC++インスタンスの2つが対応するとき、ラッパーインスタンスは
C++インスタンスよりも後に作成されることはあるが、ラッパーインスタンスが先に削除されることはあってはならない。
C++インスタンスに割り当てたIDを解除したりと面倒ごとが増えるし、何より不自然。

#### オブジェクトを返す getter
ここで言う getter は、C++オブジェクトがメンバ変数に保持しているオブジェクトの参照(ポインタ)を返すものを指す。
(オブジェクトを生成して返すだけの関数は別)

getter　が返すオブジェクトは、ラッパーインスタンスのメンバ変数に参照を保持しなければならない。
保持しない場合、返した先でラッパーインスタンスの参照が無くなった際、C++インスタンスより先にラッパーインスタンスが削除されてしまう。


### コレクション

#### 各プログラム言語ネイティブの配列に変換したりしない
あくまでオブジェクトとして扱う。
そうしないと、読み取りしかできない。(Add したときに C++ 内でオーバーライドした処理を呼ぶことができない)

例えば　ln::Collection<int> は C# の int[] にしたりしない。
C# でも ln::Collection<T> という独自のコレクションクラスを定義する。

#### C_API から書き込み可能なネイティブ配列は入出力しない
というか、サポートできない。
読み取り専用であれば入出力できる。
が、今のところ必要ではないためサポートしない。

C_API
--------------------
### 重要な関数たち
#### LNクラス名_SetBindingTypeInfo


C#
--------------------

ジェネリック
--------------------
ジェネリッククラス (LNList など) は「インスタンス化」という作業を経て、
インスタンス化されたAPI関数群 (LNSceneNodeList など) が自動生成される。

ジェネリッククラス (LNList など) が直接呼び出されることは基本的にない。
LNList_GetCount() は、自動生成される LNSceneNodeList_GetCount() が呼び出す。
Wrapper クラスは、LNList_GetCount() ではなく LNSceneNodeList_GetCount() を呼び出す。

