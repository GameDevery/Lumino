BinderMaker
====================

なぜ swig を使わないのか？
--------------------
- インターフェイスファイルにエクスポートしたい関数を書く必要がある。Lumino の C_API は C++ の超簡単なラッパーなので、.h がそのままエクスポート関数リストにできる。
- コメントは自分で解析する必要がある。結局簡単な .h の解析は自分で行わなければならない。(Altseed は doxygen から xml 作って、swig の生成したメソッドにマッチングさせていた)
- HSP 対応してない。


なぜ C言語の API をベースにするのか？(swig のように C++ から生成しないのか？)
--------------------
- それぞれ、clang の libClang と libTooling のような区切りの意味を持っている。つまり、C_API は比較的安定したインターフェイスを提供するのがねらい。


クラスライブラリの共通方針
--------------------
### オブジェクト管理

#### 一度作成されたラッパーインスタンスは、Binder 側のグローバルな map で管理する
例えば次のような場合。
```
// C#
t1 = sprite.Texture;
t2 = sprite.Texture;
```
t1 と t2 は同じオブジェクトでなければならない。

グローバルな map はウィークポインタ(ウィークリファレンス)の map でなければならない。
そうしないと、定期的に明示的なGCのようなことを行わなければならない。

#### 参照カウントの管理はラッパーインスタンスが行う
ラッパーインスタンスが生きている間は、C++インスタンスは必ず生きていなければならない。
C++インスタンスからの参照カウント管理は、言語によるかもしれないが基本的に不可能。

ラッパーインスタンスは、例えばC#ではファイナライザなどで参照カウントをデクリメントする。

ラッパーインスタンスとC++インスタンスの2つが対応するとき、ラッパーインスタンスは
C++インスタンスよりも後に作成されることはあるが、ラッパーインスタンスが先に削除されることはあってはならない。
C++インスタンスに割り当てたIDを解除したりと面倒ごとが増えるし、何より不自然。

#### オブジェクトを返す getter
ここで言う getter は、C++オブジェクトがメンバ変数に保持しているオブジェクトの参照(ポインタ)を返すものを指す。
(オブジェクトを生成して返すだけの関数は別)

getter　が返すオブジェクトは、ラッパーインスタンスのメンバ変数に参照を保持しなければならない。
保持しない場合、返した先でラッパーインスタンスの参照が無くなった際、C++インスタンスより先にラッパーインスタンスが削除されてしまう。


### コレクション

#### 各プログラム言語ネイティブの配列に変換したりしない
あくまでオブジェクトとして扱う。
そうしないと、読み取りしかできない。(Add したときに C++ 内でオーバーライドした処理を呼ぶことができない)

例えば　ln::Collection<int> は C# の int[] にしたりしない。
C# でも ln::Collection<T> という独自のコレクションクラスを定義する。

#### C_API から書き込み可能なネイティブ配列は入出力しない
というか、サポートできない。
読み取り専用であれば入出力できる。
が、今のところ必要ではないためサポートしない。

C_API
--------------------
### 重要な関数たち
#### LNクラス名_SetBindingTypeInfo


C#
--------------------

ジェネリック
--------------------
ジェネリッククラス (LNList など) は「インスタンス化」という作業を経て、
インスタンス化されたAPI関数群 (LNSceneNodeList など) が自動生成される。

ジェネリッククラス (LNList など) が直接呼び出されることは基本的にない。
LNList_GetCount() は、自動生成される LNSceneNodeList_GetCount() が呼び出す。
Wrapper クラスは、LNList_GetCount() ではなく LNSceneNodeList_GetCount() を呼び出す。

