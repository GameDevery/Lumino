BinderMaker
====================

クラスライブラリの共通方針
--------------------
### オブジェクト管理

#### 一度作成されたラッパーインスタンスは、Binder 側のグローバルな map で管理する
例えば次のような場合。
```
// C#
t1 = sprite.Texture;
t2 = sprite.Texture;
```
t1 と t2 は同じオブジェクトでなければならない。

グローバルな map はウィークポインタ(ウィークリファレンス)の map でなければならない。
そうしないと、定期的に明示的なGCのようなことを行わなければならない。

#### 参照カウントの管理はラッパーインスタンスが行う
ラッパーインスタンスが生きている間は、C++インスタンスは必ず生きていなければならない。
C++インスタンスからの参照カウント管理は、言語によるかもしれないが基本的に不可能。

ラッパーインスタンスは、例えばC#ではファイナライザなどで参照カウントをデクリメントする。

ラッパーインスタンスとC++インスタンスの2つが対応するとき、ラッパーインスタンスは
C++インスタンスよりも後に作成されることはあるが、ラッパーインスタンスが先に削除されることはあってはならない。
C++インスタンスに割り当てたIDを解除したりと面倒ごとが増えるし、何より不自然。

#### オブジェクトを返す getter
ここで言う getter は、C++オブジェクトがメンバ変数に保持しているオブジェクトの参照(ポインタ)を返すものを指す。
(オブジェクトを生成して返すだけの関数は別)

getter　が返すオブジェクトは、ラッパーインスタンスのメンバ変数に参照を保持しなければならない。
保持しない場合、返した先でラッパーインスタンスの参照が無くなった際、C++インスタンスより先にラッパーインスタンスが削除されてしまう。


### コレクション

#### 各プログラム言語ネイティブの配列に変換したりしない
あくまでオブジェクトとして扱う。
そうしないと、読み取りしかできない。(Add したときに C++ 内でオーバーライドした処理を呼ぶことができない)

例えば　ln::Collection<int> は C# の int[] にしたりしない。
C# でも ln::Collection<T> という独自のコレクションクラスを定義する。

#### C_API から書き込み可能なネイティブ配列は入出力しない
というか、サポートできない。
読み取り専用であれば入出力できる。
が、今のところ必要ではないためサポートしない。

C_API
--------------------
### 重要な関数たち
#### LNクラス名_SetBindingTypeInfo


C#
--------------------
