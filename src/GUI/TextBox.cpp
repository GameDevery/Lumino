/*
	[2015/8/25]
		・実際に画面に表示する Inline は Visual なんたらにしておく。
		　これはいうなれば論理要素に対する物理要素。
		 　オブジェクト化しておくことで、アニメーションもやりやすい。

		・AvalonEdit では、物理ピクセル→論理行の変換は Rendering.HeightTree の役目。
		Rendering.HeightTree は、この変換というか検索を高速に行う赤黒木。

		・Visual の作成は Measure で。

		・改行は1文字。\r\nも1文字。
*/
#include "../Internal.h"
#include <Lumino/GUI/GUIManager.h>
#include <Lumino/GUI/TextBox.h>
#include <Lumino/Documents/DocumentsRenderer.h>
#include <Lumino/Documents/Run.h>

namespace Lumino
{
namespace GUI
{


// 本格的なテキストエディタであれば装飾のため、さらに単語単位に区切ったりする。
// ここの TextBox は文字ごとに装飾とかは考えないシンプルなものなので、まずは行単位。
class TextBox::LineSegment
	: public RefObject
{
public:
	LineSegment(const TCHAR* str, int len)
	{
		m_text.Append(str, len);
	}

	//int GetLength() const
	//{

	//}

public:
	StringBuilder	m_text;
	//int				m_realCharCount;

	RefPtr<Graphics::GlyphRun>		m_glyphRun;	// 本来なら View と分けるべき。ただ、今回はシンプル重視で。
};

class TextBox::Document
{
public:
	//int GetLength() const {  }

	void Replace(int start, int length, const String& text)
	{
		// TODO:とりあえず初回前提
		const TCHAR* begin = text.GetCStr();
		const TCHAR* end = begin + text.GetLength();
		int nlIndex, nlCount;
		while (StringTraits::IndexOfNewLineSequence(begin, end, &nlIndex, &nlCount))
		{
			RefPtr<TextBox::LineSegment> line(LN_NEW LineSegment(begin, nlIndex));
			m_lineSegments.Add(line);
			begin += (nlIndex + nlCount);	// 改行文字の次の文字を指す
		}
		if (begin != end)
		{
			RefPtr<TextBox::LineSegment> line(LN_NEW LineSegment(begin, nlIndex));
			m_lineSegments.Add(line);
		}
	}

public:
	Array< RefPtr<TextBox::LineSegment> >	m_lineSegments;
};




//=============================================================================
// TextBox
//=============================================================================
LN_CORE_OBJECT_TYPE_INFO_IMPL(TextBox, Control);
LN_UI_ELEMENT_SUBCLASS_IMPL(TextBox);

LN_PROPERTY_IMPLEMENT_GETTER_SETTER(TextBox, String, TextProperty, "Text", get_Text, set_Text, PropertyMetadata(String::GetEmpty()));

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
TextBox* TextBox::Create(GUIManager* manager)
{
	RefPtr<TextBox> obj(LN_NEW TextBox(manager));
	obj->InitializeComponent();
	obj.SafeAddRef();
	return obj;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
TextBox::TextBox(GUIManager* manager)
	: Control(manager)
	, m_document(NULL)
{
	m_document = LN_NEW Document();
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
TextBox::~TextBox()
{
	LN_SAFE_DELETE(m_document);
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void TextBox::OnRender(Graphics::Painter* painter)
{
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void TextBox::set_Text(const String& string)
{
	// TODO: プロパティ初期値セットされてない
	m_document->Replace(0, 0, string);	// TODO: GetLength()
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
const String& TextBox::get_Text() const
{
	return String::GetEmpty();
}

} // namespace GUI
} // namespace Lumino

