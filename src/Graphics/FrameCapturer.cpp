/*
	GIF フォーマット
	https://www.w3.org/Graphics/GIF/spec-gif89a.txt
*/
#include "Internal.h"
#include <giflib-5.1.4\gif_lib.h>
#include "../../../external/jo_gif/jo_gif.cpp"
#include <Lumino/Graphics/Texture.h>
#include <Lumino/Graphics/FrameCapturer.h>
#include "GraphicsManager.h"
#include "RenderingCommand.h"
#include "RenderingThread.h"

LN_NAMESPACE_BEGIN
LN_NAMESPACE_GRAPHICS_BEGIN



class FrameCapturer::GifContext
{
public:

	GifContext()
		: m_gif(nullptr)
		, m_globalPalette(nullptr)
	{
	}

	~GifContext()
	{
		Close();
	}

	void Open(const PathNameA& filePath, const Size& size)
	{
		m_imageSize = size;
		m_line.Alloc(sizeof(GifPixelType) * m_imageSize.width);

		int error;
		m_gif = EGifOpenFileName(filePath.c_str(), false, &error);

		m_globalPalette = GifMakeMapObject(256, PaletteGPriority);

		EGifPutScreenDesc(m_gif, size.width, size.height, 256, 0, m_globalPalette);

		EGifPutExtensionLeader(m_gif, APPLICATION_EXT_FUNC_CODE);
		EGifPutExtensionBlock(m_gif, 11, "NETSCAPE2.0");	// 固定

		// Data Sub-blocks
		int loop_count = 0;
		char subblock[3];
		subblock[0] = 1;
		subblock[2] = loop_count % 256;
		subblock[1] = loop_count / 256;
		EGifPutExtensionRaw(m_gif, 3, subblock);

		EGifPutExtensionTrailer(m_gif);
	}

	void Close()
	{
		int error;
		EGifCloseFile(m_gif, &error);

		GifFreeMapObject(m_globalPalette);
	}

	void AddFrame(Bitmap* bitmap, int delayMS)
	{
		if (delayMS > 0) return;

		// Graphic Control Extension
		byte_t ext[4] = { 0x04, 0x00, 0x00, 0xff };
		ext[1] = (delayMS) % 256;	// TODO: ビット演算で。
		ext[2] = (delayMS) / 256;	// TODO: ビット演算で。
		EGifPutExtension(m_gif, GRAPHICS_EXT_FUNC_CODE, 4, ext);

		// Image Descriptor
		EGifPutImageDesc(m_gif, 0, 0, m_imageSize.width, m_imageSize.height, false, nullptr);


		const Size& bmpSize = bitmap->GetSize();
		GifPixelType* line = (GifPixelType*)m_line.GetData();
		for (int y = 0; y < m_imageSize.height; ++y)
		{
			for (int x = 0; x < m_imageSize.width; ++x)
			{
				GifPixelType* p = &line[x];
				if (x >= bmpSize.width || y >= bmpSize.height)
				{
					*p = 0x00;
				}
				else
				{
					*p = PeekR4G2B4Index(bitmap->GetPixel(x, y));
				}
			}

			EGifPutLine(m_gif, line, m_imageSize.width);
		}
	}

	uint8_t PeekR4G2B4Index(const Color& c)
	{
		return
			((c.r / 32) & 0x0F) |
			(((c.g / 64) & 0x03) << 3) |
			(((c.b / 32) & 0x0F) << 5);
	}

	static const GifColorType PaletteGPriority[256];

private:
	GifFileType*	m_gif;
	ColorMapObject*	m_globalPalette;
	Size			m_imageSize;
	ByteBuffer		m_line;
};

const GifColorType FrameCapturer::GifContext::PaletteGPriority[256] =
{
	{ 0x00, 0x00, 0x00 },{ 0x1E, 0x00, 0x00 },{ 0x3C, 0x00, 0x00 },{ 0x5A, 0x00, 0x00 },{ 0x78, 0x00, 0x00 },{ 0x96, 0x00, 0x00 },{ 0xB4, 0x00, 0x00 },{ 0xFF, 0x00, 0x00 },
	{ 0x00, 0x3E, 0x00 },{ 0x1E, 0x3E, 0x00 },{ 0x3C, 0x3E, 0x00 },{ 0x5A, 0x3E, 0x00 },{ 0x78, 0x3E, 0x00 },{ 0x96, 0x3E, 0x00 },{ 0xB4, 0x3E, 0x00 },{ 0xFF, 0x3E, 0x00 },
	{ 0x00, 0x7C, 0x00 },{ 0x1E, 0x7C, 0x00 },{ 0x3C, 0x7C, 0x00 },{ 0x5A, 0x7C, 0x00 },{ 0x78, 0x7C, 0x00 },{ 0x96, 0x7C, 0x00 },{ 0xB4, 0x7C, 0x00 },{ 0xFF, 0x7C, 0x00 },
	{ 0x00, 0xFF, 0x00 },{ 0x1E, 0xFF, 0x00 },{ 0x3C, 0xFF, 0x00 },{ 0x5A, 0xFF, 0x00 },{ 0x78, 0xFF, 0x00 },{ 0x96, 0xFF, 0x00 },{ 0xB4, 0xFF, 0x00 },{ 0xFF, 0xFF, 0x00 },
	{ 0x00, 0x00, 0x1E },{ 0x1E, 0x00, 0x1E },{ 0x3C, 0x00, 0x1E },{ 0x5A, 0x00, 0x1E },{ 0x78, 0x00, 0x1E },{ 0x96, 0x00, 0x1E },{ 0xB4, 0x00, 0x1E },{ 0xFF, 0x00, 0x1E },
	{ 0x00, 0x3E, 0x1E },{ 0x1E, 0x3E, 0x1E },{ 0x3C, 0x3E, 0x1E },{ 0x5A, 0x3E, 0x1E },{ 0x78, 0x3E, 0x1E },{ 0x96, 0x3E, 0x1E },{ 0xB4, 0x3E, 0x1E },{ 0xFF, 0x3E, 0x1E },
	{ 0x00, 0x7C, 0x1E },{ 0x1E, 0x7C, 0x1E },{ 0x3C, 0x7C, 0x1E },{ 0x5A, 0x7C, 0x1E },{ 0x78, 0x7C, 0x1E },{ 0x96, 0x7C, 0x1E },{ 0xB4, 0x7C, 0x1E },{ 0xFF, 0x7C, 0x1E },
	{ 0x00, 0xFF, 0x1E },{ 0x1E, 0xFF, 0x1E },{ 0x3C, 0xFF, 0x1E },{ 0x5A, 0xFF, 0x1E },{ 0x78, 0xFF, 0x1E },{ 0x96, 0xFF, 0x1E },{ 0xB4, 0xFF, 0x1E },{ 0xFF, 0xFF, 0x1E },
	{ 0x00, 0x00, 0x3C },{ 0x1E, 0x00, 0x3C },{ 0x3C, 0x00, 0x3C },{ 0x5A, 0x00, 0x3C },{ 0x78, 0x00, 0x3C },{ 0x96, 0x00, 0x3C },{ 0xB4, 0x00, 0x3C },{ 0xFF, 0x00, 0x3C },
	{ 0x00, 0x3E, 0x3C },{ 0x1E, 0x3E, 0x3C },{ 0x3C, 0x3E, 0x3C },{ 0x5A, 0x3E, 0x3C },{ 0x78, 0x3E, 0x3C },{ 0x96, 0x3E, 0x3C },{ 0xB4, 0x3E, 0x3C },{ 0xFF, 0x3E, 0x3C },
	{ 0x00, 0x7C, 0x3C },{ 0x1E, 0x7C, 0x3C },{ 0x3C, 0x7C, 0x3C },{ 0x5A, 0x7C, 0x3C },{ 0x78, 0x7C, 0x3C },{ 0x96, 0x7C, 0x3C },{ 0xB4, 0x7C, 0x3C },{ 0xFF, 0x7C, 0x3C },
	{ 0x00, 0xFF, 0x3C },{ 0x1E, 0xFF, 0x3C },{ 0x3C, 0xFF, 0x3C },{ 0x5A, 0xFF, 0x3C },{ 0x78, 0xFF, 0x3C },{ 0x96, 0xFF, 0x3C },{ 0xB4, 0xFF, 0x3C },{ 0xFF, 0xFF, 0x3C },
	{ 0x00, 0x00, 0x5A },{ 0x1E, 0x00, 0x5A },{ 0x3C, 0x00, 0x5A },{ 0x5A, 0x00, 0x5A },{ 0x78, 0x00, 0x5A },{ 0x96, 0x00, 0x5A },{ 0xB4, 0x00, 0x5A },{ 0xFF, 0x00, 0x5A },
	{ 0x00, 0x3E, 0x5A },{ 0x1E, 0x3E, 0x5A },{ 0x3C, 0x3E, 0x5A },{ 0x5A, 0x3E, 0x5A },{ 0x78, 0x3E, 0x5A },{ 0x96, 0x3E, 0x5A },{ 0xB4, 0x3E, 0x5A },{ 0xFF, 0x3E, 0x5A },
	{ 0x00, 0x7C, 0x5A },{ 0x1E, 0x7C, 0x5A },{ 0x3C, 0x7C, 0x5A },{ 0x5A, 0x7C, 0x5A },{ 0x78, 0x7C, 0x5A },{ 0x96, 0x7C, 0x5A },{ 0xB4, 0x7C, 0x5A },{ 0xFF, 0x7C, 0x5A },
	{ 0x00, 0xFF, 0x5A },{ 0x1E, 0xFF, 0x5A },{ 0x3C, 0xFF, 0x5A },{ 0x5A, 0xFF, 0x5A },{ 0x78, 0xFF, 0x5A },{ 0x96, 0xFF, 0x5A },{ 0xB4, 0xFF, 0x5A },{ 0xFF, 0xFF, 0x5A },
	{ 0x00, 0x00, 0x78 },{ 0x1E, 0x00, 0x78 },{ 0x3C, 0x00, 0x78 },{ 0x5A, 0x00, 0x78 },{ 0x78, 0x00, 0x78 },{ 0x96, 0x00, 0x78 },{ 0xB4, 0x00, 0x78 },{ 0xFF, 0x00, 0x78 },
	{ 0x00, 0x3E, 0x78 },{ 0x1E, 0x3E, 0x78 },{ 0x3C, 0x3E, 0x78 },{ 0x5A, 0x3E, 0x78 },{ 0x78, 0x3E, 0x78 },{ 0x96, 0x3E, 0x78 },{ 0xB4, 0x3E, 0x78 },{ 0xFF, 0x3E, 0x78 },
	{ 0x00, 0x7C, 0x78 },{ 0x1E, 0x7C, 0x78 },{ 0x3C, 0x7C, 0x78 },{ 0x5A, 0x7C, 0x78 },{ 0x78, 0x7C, 0x78 },{ 0x96, 0x7C, 0x78 },{ 0xB4, 0x7C, 0x78 },{ 0xFF, 0x7C, 0x78 },
	{ 0x00, 0xFF, 0x78 },{ 0x1E, 0xFF, 0x78 },{ 0x3C, 0xFF, 0x78 },{ 0x5A, 0xFF, 0x78 },{ 0x78, 0xFF, 0x78 },{ 0x96, 0xFF, 0x78 },{ 0xB4, 0xFF, 0x78 },{ 0xFF, 0xFF, 0x78 },
	{ 0x00, 0x00, 0x96 },{ 0x1E, 0x00, 0x96 },{ 0x3C, 0x00, 0x96 },{ 0x5A, 0x00, 0x96 },{ 0x78, 0x00, 0x96 },{ 0x96, 0x00, 0x96 },{ 0xB4, 0x00, 0x96 },{ 0xFF, 0x00, 0x96 },
	{ 0x00, 0x3E, 0x96 },{ 0x1E, 0x3E, 0x96 },{ 0x3C, 0x3E, 0x96 },{ 0x5A, 0x3E, 0x96 },{ 0x78, 0x3E, 0x96 },{ 0x96, 0x3E, 0x96 },{ 0xB4, 0x3E, 0x96 },{ 0xFF, 0x3E, 0x96 },
	{ 0x00, 0x7C, 0x96 },{ 0x1E, 0x7C, 0x96 },{ 0x3C, 0x7C, 0x96 },{ 0x5A, 0x7C, 0x96 },{ 0x78, 0x7C, 0x96 },{ 0x96, 0x7C, 0x96 },{ 0xB4, 0x7C, 0x96 },{ 0xFF, 0x7C, 0x96 },
	{ 0x00, 0xFF, 0x96 },{ 0x1E, 0xFF, 0x96 },{ 0x3C, 0xFF, 0x96 },{ 0x5A, 0xFF, 0x96 },{ 0x78, 0xFF, 0x96 },{ 0x96, 0xFF, 0x96 },{ 0xB4, 0xFF, 0x96 },{ 0xFF, 0xFF, 0x96 },
	{ 0x00, 0x00, 0xB4 },{ 0x1E, 0x00, 0xB4 },{ 0x3C, 0x00, 0xB4 },{ 0x5A, 0x00, 0xB4 },{ 0x78, 0x00, 0xB4 },{ 0x96, 0x00, 0xB4 },{ 0xB4, 0x00, 0xB4 },{ 0xFF, 0x00, 0xB4 },
	{ 0x00, 0x3E, 0xB4 },{ 0x1E, 0x3E, 0xB4 },{ 0x3C, 0x3E, 0xB4 },{ 0x5A, 0x3E, 0xB4 },{ 0x78, 0x3E, 0xB4 },{ 0x96, 0x3E, 0xB4 },{ 0xB4, 0x3E, 0xB4 },{ 0xFF, 0x3E, 0xB4 },
	{ 0x00, 0x7C, 0xB4 },{ 0x1E, 0x7C, 0xB4 },{ 0x3C, 0x7C, 0xB4 },{ 0x5A, 0x7C, 0xB4 },{ 0x78, 0x7C, 0xB4 },{ 0x96, 0x7C, 0xB4 },{ 0xB4, 0x7C, 0xB4 },{ 0xFF, 0x7C, 0xB4 },
	{ 0x00, 0xFF, 0xB4 },{ 0x1E, 0xFF, 0xB4 },{ 0x3C, 0xFF, 0xB4 },{ 0x5A, 0xFF, 0xB4 },{ 0x78, 0xFF, 0xB4 },{ 0x96, 0xFF, 0xB4 },{ 0xB4, 0xFF, 0xB4 },{ 0xFF, 0xFF, 0xB4 },
	{ 0x00, 0x00, 0xFF },{ 0x1E, 0x00, 0xFF },{ 0x3C, 0x00, 0xFF },{ 0x5A, 0x00, 0xFF },{ 0x78, 0x00, 0xFF },{ 0x96, 0x00, 0xFF },{ 0xB4, 0x00, 0xFF },{ 0xFF, 0x00, 0xFF },
	{ 0x00, 0x3E, 0xFF },{ 0x1E, 0x3E, 0xFF },{ 0x3C, 0x3E, 0xFF },{ 0x5A, 0x3E, 0xFF },{ 0x78, 0x3E, 0xFF },{ 0x96, 0x3E, 0xFF },{ 0xB4, 0x3E, 0xFF },{ 0xFF, 0x3E, 0xFF },
	{ 0x00, 0x7C, 0xFF },{ 0x1E, 0x7C, 0xFF },{ 0x3C, 0x7C, 0xFF },{ 0x5A, 0x7C, 0xFF },{ 0x78, 0x7C, 0xFF },{ 0x96, 0x7C, 0xFF },{ 0xB4, 0x7C, 0xFF },{ 0xFF, 0x7C, 0xFF },
	{ 0x00, 0xFF, 0xFF },{ 0x1E, 0xFF, 0xFF },{ 0x3C, 0xFF, 0xFF },{ 0x5A, 0xFF, 0xFF },{ 0x78, 0xFF, 0xFF },{ 0x96, 0xFF, 0xFF },{ 0xB4, 0xFF, 0xFF },{ 0xFF, 0xFF, 0xFF },
};

//==============================================================================
// FrameCapturer
//==============================================================================

//------------------------------------------------------------------------------
FrameCapturerPtr FrameCapturer::Create()
{
	auto ptr = FrameCapturerPtr::MakeRef();
	ptr->Initialize(GraphicsManager::GetInstance());
	return ptr;
}

//------------------------------------------------------------------------------
FrameCapturer::FrameCapturer()
	: m_manager(nullptr)
	, m_capturerTarget(nullptr)
	, m_requestedState(State::Stoped)
	, m_gifContext(nullptr)
	, m_currentState(State::Stoped)
	, m_lastTick(0)
{
}

//------------------------------------------------------------------------------
FrameCapturer::~FrameCapturer()
{
	LN_SAFE_RELEASE(m_capturerTarget);
	LN_SAFE_DELETE(m_gifContext);
}

//------------------------------------------------------------------------------
void FrameCapturer::Initialize(GraphicsManager* manager)
{
	m_manager = manager;
	m_gifContext = LN_NEW GifContext;
}

//------------------------------------------------------------------------------
void FrameCapturer::SetCapturerTarget(RenderTarget* renderTarget)
{
	LN_REFOBJ_SET(m_capturerTarget, renderTarget);
}

//------------------------------------------------------------------------------
void FrameCapturer::StartRecording()
{
	m_requestedState = State::Recording;
}

//------------------------------------------------------------------------------
void FrameCapturer::StopRecording()
{
	m_requestedState = State::Stoped;
}

//------------------------------------------------------------------------------
void FrameCapturer::Record()
{
	LN_CHECK_STATE(m_capturerTarget != nullptr);


	RefPtr<FrameCapturer> fc = this;
	Driver::ITexture* target = m_capturerTarget->GetDeviceObject();
	State newState = m_requestedState;

	LN_ENQUEUE_RENDER_COMMAND_3(
		FrameCapturer_Record, m_manager,
		RefPtr<FrameCapturer>, fc,
		RefPtr<Driver::ITexture>, target,
		State, newState,
		{
			fc->RecordCommand(target, newState);
		});
}

//------------------------------------------------------------------------------
void FrameCapturer::RecordCommand(Driver::ITexture* target, State newState)
{
	// 録画状態の変化確認
	if (newState != m_currentState)
	{
		if (newState == State::Stoped)
		{
			m_gifContext->Close();
		}
		else if (newState == State::Recording)
		{
			PathNameA filePath("FrameCapturer.gif");
			m_gifContext->Open(filePath, target->GetSize());
			m_lastTick = 0;
		}
		m_currentState = newState;
	}

	// 録画
	if (m_currentState == State::Recording)
	{
		// 差分時間計算
		uint64_t deltaTick = 0;
		uint64_t curTick = Environment::GetTickCount();
		if (m_lastTick != 0) deltaTick = curTick - m_lastTick;

		// RenderTarget の内容を読み取る
		Bitmap* bmp = target->Lock();	//TODO: Scoped
		m_gifContext->AddFrame(bmp, deltaTick);
		target->Unlock();

		m_lastTick = curTick;
	}
}

LN_NAMESPACE_GRAPHICS_END
LN_NAMESPACE_END
