/*
	GIF フォーマット
	https://www.w3.org/Graphics/GIF/spec-gif89a.txt
*/
#include "Internal.h"
#include <giflib-5.1.4\gif_lib.h>
#include "../../../external/jo_gif/jo_gif.cpp"
#include <Lumino/Graphics/Texture.h>
#include <Lumino/Graphics/FrameCapturer.h>
#include "GraphicsManager.h"
#include "RenderingCommand.h"
#include "RenderingThread.h"

LN_NAMESPACE_BEGIN
LN_NAMESPACE_GRAPHICS_BEGIN



class FrameCapturer::GifContext
{
public:

	GifContext()
		: m_gif(nullptr)
		, m_globalPalette(nullptr)
	{
	}

	~GifContext()
	{
		Close();
	}

	void Open(const PathNameA& filePath, const Size& size)
	{
		m_imageSize = size;
		m_line.Alloc(sizeof(GifPixelType) * m_imageSize.width);

		int error;
		m_gif = EGifOpenFileName(filePath.c_str(), false, &error);

		m_globalPalette = GifMakeMapObject(256, PaletteGPriority);

		EGifPutScreenDesc(m_gif, size.width, size.height, 256, 0, m_globalPalette);

		EGifPutExtensionLeader(m_gif, APPLICATION_EXT_FUNC_CODE);
		EGifPutExtensionBlock(m_gif, 11, "NETSCAPE2.0");	// 固定

		// Data Sub-blocks
		int loop_count = 0;
		char subblock[3];
		subblock[0] = 1;
		subblock[2] = loop_count % 256;
		subblock[1] = loop_count / 256;
		EGifPutExtensionRaw(m_gif, 3, subblock);

		EGifPutExtensionTrailer(m_gif);
	}

	void Close()
	{
		int error;
		EGifCloseFile(m_gif, &error);

		GifFreeMapObject(m_globalPalette);
	}

	void AddFrame(Bitmap* bitmap, int delayCsec)
	{
		// graphics control block
		byte_t ext[4] = { 0x04, 0x00, 0x00, 0xff };
		ext[1] = delayCsec % 256;	// TODO: ビット演算で。
		ext[2] = delayCsec / 256;	// TODO: ビット演算で。
		EGifPutExtension(m_gif, GRAPHICS_EXT_FUNC_CODE, 4, ext);

		// Image Descriptor
		EGifPutImageDesc(m_gif, 0, 0, m_imageSize.width, m_imageSize.height, false, nullptr);


		const Size& bmpSize = bitmap->GetSize();
		GifPixelType* line = (GifPixelType*)m_line.GetData();
		for (int y = 0; y < m_imageSize.height; ++y)
		{
			for (int x = 0; x < m_imageSize.width; ++x)
			{
				GifPixelType* p = &line[x];
				if (x >= bmpSize.width || y >= bmpSize.height)
				{
					*p = 0x00;
				}
				else
				{
					*p = PeekR4G2B4Index(bitmap->GetPixel(x, y));
				}
			}

			EGifPutLine(m_gif, line, m_imageSize.width);
		}
	}

	uint8_t PeekR4G2B4Index(const Color& c)
	{
		return
			((c.r / 32) & 0x0F) |
			(((c.g / 64) & 0x03) << 4) |
			(((c.b / 32) & 0x0F) << 6);
	}

	static const GifColorType PaletteGPriority[256];

private:
	GifFileType*	m_gif;
	ColorMapObject*	m_globalPalette;
	Size			m_imageSize;
	ByteBuffer		m_line;
};

const GifColorType FrameCapturer::GifContext::PaletteGPriority[256] =
{
	{ 0x00, 0x00, 0x00 },{ 0x1E, 0x00, 0x00 },{ 0x3C, 0x00, 0x00 },{ 0x5A, 0x00, 0x00 },{ 0x78, 0x00, 0x00 },{ 0x96, 0x00, 0x00 },{ 0xB4, 0x00, 0x00 },{ 0xFF, 0x00, 0x00 },
	{ 0x00, 0x3E, 0x00 },{ 0x1E, 0x3E, 0x00 },{ 0x3C, 0x3E, 0x00 },{ 0x5A, 0x3E, 0x00 },{ 0x78, 0x3E, 0x00 },{ 0x96, 0x3E, 0x00 },{ 0xB4, 0x3E, 0x00 },{ 0xFF, 0x3E, 0x00 },
	{ 0x00, 0x7C, 0x00 },{ 0x1E, 0x7C, 0x00 },{ 0x3C, 0x7C, 0x00 },{ 0x5A, 0x7C, 0x00 },{ 0x78, 0x7C, 0x00 },{ 0x96, 0x7C, 0x00 },{ 0xB4, 0x7C, 0x00 },{ 0xFF, 0x7C, 0x00 },
	{ 0x00, 0xFF, 0x00 },{ 0x1E, 0xFF, 0x00 },{ 0x3C, 0xFF, 0x00 },{ 0x5A, 0xFF, 0x00 },{ 0x78, 0xFF, 0x00 },{ 0x96, 0xFF, 0x00 },{ 0xB4, 0xFF, 0x00 },{ 0xFF, 0xFF, 0x00 },
	{ 0x00, 0x00, 0x1E },{ 0x1E, 0x00, 0x1E },{ 0x3C, 0x00, 0x1E },{ 0x5A, 0x00, 0x1E },{ 0x78, 0x00, 0x1E },{ 0x96, 0x00, 0x1E },{ 0xB4, 0x00, 0x1E },{ 0xFF, 0x00, 0x1E },
	{ 0x00, 0x3E, 0x1E },{ 0x1E, 0x3E, 0x1E },{ 0x3C, 0x3E, 0x1E },{ 0x5A, 0x3E, 0x1E },{ 0x78, 0x3E, 0x1E },{ 0x96, 0x3E, 0x1E },{ 0xB4, 0x3E, 0x1E },{ 0xFF, 0x3E, 0x1E },
	{ 0x00, 0x7C, 0x1E },{ 0x1E, 0x7C, 0x1E },{ 0x3C, 0x7C, 0x1E },{ 0x5A, 0x7C, 0x1E },{ 0x78, 0x7C, 0x1E },{ 0x96, 0x7C, 0x1E },{ 0xB4, 0x7C, 0x1E },{ 0xFF, 0x7C, 0x1E },
	{ 0x00, 0xFF, 0x1E },{ 0x1E, 0xFF, 0x1E },{ 0x3C, 0xFF, 0x1E },{ 0x5A, 0xFF, 0x1E },{ 0x78, 0xFF, 0x1E },{ 0x96, 0xFF, 0x1E },{ 0xB4, 0xFF, 0x1E },{ 0xFF, 0xFF, 0x1E },
	{ 0x00, 0x00, 0x3C },{ 0x1E, 0x00, 0x3C },{ 0x3C, 0x00, 0x3C },{ 0x5A, 0x00, 0x3C },{ 0x78, 0x00, 0x3C },{ 0x96, 0x00, 0x3C },{ 0xB4, 0x00, 0x3C },{ 0xFF, 0x00, 0x3C },
	{ 0x00, 0x3E, 0x3C },{ 0x1E, 0x3E, 0x3C },{ 0x3C, 0x3E, 0x3C },{ 0x5A, 0x3E, 0x3C },{ 0x78, 0x3E, 0x3C },{ 0x96, 0x3E, 0x3C },{ 0xB4, 0x3E, 0x3C },{ 0xFF, 0x3E, 0x3C },
	{ 0x00, 0x7C, 0x3C },{ 0x1E, 0x7C, 0x3C },{ 0x3C, 0x7C, 0x3C },{ 0x5A, 0x7C, 0x3C },{ 0x78, 0x7C, 0x3C },{ 0x96, 0x7C, 0x3C },{ 0xB4, 0x7C, 0x3C },{ 0xFF, 0x7C, 0x3C },
	{ 0x00, 0xFF, 0x3C },{ 0x1E, 0xFF, 0x3C },{ 0x3C, 0xFF, 0x3C },{ 0x5A, 0xFF, 0x3C },{ 0x78, 0xFF, 0x3C },{ 0x96, 0xFF, 0x3C },{ 0xB4, 0xFF, 0x3C },{ 0xFF, 0xFF, 0x3C },
	{ 0x00, 0x00, 0x5A },{ 0x1E, 0x00, 0x5A },{ 0x3C, 0x00, 0x5A },{ 0x5A, 0x00, 0x5A },{ 0x78, 0x00, 0x5A },{ 0x96, 0x00, 0x5A },{ 0xB4, 0x00, 0x5A },{ 0xFF, 0x00, 0x5A },
	{ 0x00, 0x3E, 0x5A },{ 0x1E, 0x3E, 0x5A },{ 0x3C, 0x3E, 0x5A },{ 0x5A, 0x3E, 0x5A },{ 0x78, 0x3E, 0x5A },{ 0x96, 0x3E, 0x5A },{ 0xB4, 0x3E, 0x5A },{ 0xFF, 0x3E, 0x5A },
	{ 0x00, 0x7C, 0x5A },{ 0x1E, 0x7C, 0x5A },{ 0x3C, 0x7C, 0x5A },{ 0x5A, 0x7C, 0x5A },{ 0x78, 0x7C, 0x5A },{ 0x96, 0x7C, 0x5A },{ 0xB4, 0x7C, 0x5A },{ 0xFF, 0x7C, 0x5A },
	{ 0x00, 0xFF, 0x5A },{ 0x1E, 0xFF, 0x5A },{ 0x3C, 0xFF, 0x5A },{ 0x5A, 0xFF, 0x5A },{ 0x78, 0xFF, 0x5A },{ 0x96, 0xFF, 0x5A },{ 0xB4, 0xFF, 0x5A },{ 0xFF, 0xFF, 0x5A },
	{ 0x00, 0x00, 0x78 },{ 0x1E, 0x00, 0x78 },{ 0x3C, 0x00, 0x78 },{ 0x5A, 0x00, 0x78 },{ 0x78, 0x00, 0x78 },{ 0x96, 0x00, 0x78 },{ 0xB4, 0x00, 0x78 },{ 0xFF, 0x00, 0x78 },
	{ 0x00, 0x3E, 0x78 },{ 0x1E, 0x3E, 0x78 },{ 0x3C, 0x3E, 0x78 },{ 0x5A, 0x3E, 0x78 },{ 0x78, 0x3E, 0x78 },{ 0x96, 0x3E, 0x78 },{ 0xB4, 0x3E, 0x78 },{ 0xFF, 0x3E, 0x78 },
	{ 0x00, 0x7C, 0x78 },{ 0x1E, 0x7C, 0x78 },{ 0x3C, 0x7C, 0x78 },{ 0x5A, 0x7C, 0x78 },{ 0x78, 0x7C, 0x78 },{ 0x96, 0x7C, 0x78 },{ 0xB4, 0x7C, 0x78 },{ 0xFF, 0x7C, 0x78 },
	{ 0x00, 0xFF, 0x78 },{ 0x1E, 0xFF, 0x78 },{ 0x3C, 0xFF, 0x78 },{ 0x5A, 0xFF, 0x78 },{ 0x78, 0xFF, 0x78 },{ 0x96, 0xFF, 0x78 },{ 0xB4, 0xFF, 0x78 },{ 0xFF, 0xFF, 0x78 },
	{ 0x00, 0x00, 0x96 },{ 0x1E, 0x00, 0x96 },{ 0x3C, 0x00, 0x96 },{ 0x5A, 0x00, 0x96 },{ 0x78, 0x00, 0x96 },{ 0x96, 0x00, 0x96 },{ 0xB4, 0x00, 0x96 },{ 0xFF, 0x00, 0x96 },
	{ 0x00, 0x3E, 0x96 },{ 0x1E, 0x3E, 0x96 },{ 0x3C, 0x3E, 0x96 },{ 0x5A, 0x3E, 0x96 },{ 0x78, 0x3E, 0x96 },{ 0x96, 0x3E, 0x96 },{ 0xB4, 0x3E, 0x96 },{ 0xFF, 0x3E, 0x96 },
	{ 0x00, 0x7C, 0x96 },{ 0x1E, 0x7C, 0x96 },{ 0x3C, 0x7C, 0x96 },{ 0x5A, 0x7C, 0x96 },{ 0x78, 0x7C, 0x96 },{ 0x96, 0x7C, 0x96 },{ 0xB4, 0x7C, 0x96 },{ 0xFF, 0x7C, 0x96 },
	{ 0x00, 0xFF, 0x96 },{ 0x1E, 0xFF, 0x96 },{ 0x3C, 0xFF, 0x96 },{ 0x5A, 0xFF, 0x96 },{ 0x78, 0xFF, 0x96 },{ 0x96, 0xFF, 0x96 },{ 0xB4, 0xFF, 0x96 },{ 0xFF, 0xFF, 0x96 },
	{ 0x00, 0x00, 0xB4 },{ 0x1E, 0x00, 0xB4 },{ 0x3C, 0x00, 0xB4 },{ 0x5A, 0x00, 0xB4 },{ 0x78, 0x00, 0xB4 },{ 0x96, 0x00, 0xB4 },{ 0xB4, 0x00, 0xB4 },{ 0xFF, 0x00, 0xB4 },
	{ 0x00, 0x3E, 0xB4 },{ 0x1E, 0x3E, 0xB4 },{ 0x3C, 0x3E, 0xB4 },{ 0x5A, 0x3E, 0xB4 },{ 0x78, 0x3E, 0xB4 },{ 0x96, 0x3E, 0xB4 },{ 0xB4, 0x3E, 0xB4 },{ 0xFF, 0x3E, 0xB4 },
	{ 0x00, 0x7C, 0xB4 },{ 0x1E, 0x7C, 0xB4 },{ 0x3C, 0x7C, 0xB4 },{ 0x5A, 0x7C, 0xB4 },{ 0x78, 0x7C, 0xB4 },{ 0x96, 0x7C, 0xB4 },{ 0xB4, 0x7C, 0xB4 },{ 0xFF, 0x7C, 0xB4 },
	{ 0x00, 0xFF, 0xB4 },{ 0x1E, 0xFF, 0xB4 },{ 0x3C, 0xFF, 0xB4 },{ 0x5A, 0xFF, 0xB4 },{ 0x78, 0xFF, 0xB4 },{ 0x96, 0xFF, 0xB4 },{ 0xB4, 0xFF, 0xB4 },{ 0xFF, 0xFF, 0xB4 },
	{ 0x00, 0x00, 0xFF },{ 0x1E, 0x00, 0xFF },{ 0x3C, 0x00, 0xFF },{ 0x5A, 0x00, 0xFF },{ 0x78, 0x00, 0xFF },{ 0x96, 0x00, 0xFF },{ 0xB4, 0x00, 0xFF },{ 0xFF, 0x00, 0xFF },
	{ 0x00, 0x3E, 0xFF },{ 0x1E, 0x3E, 0xFF },{ 0x3C, 0x3E, 0xFF },{ 0x5A, 0x3E, 0xFF },{ 0x78, 0x3E, 0xFF },{ 0x96, 0x3E, 0xFF },{ 0xB4, 0x3E, 0xFF },{ 0xFF, 0x3E, 0xFF },
	{ 0x00, 0x7C, 0xFF },{ 0x1E, 0x7C, 0xFF },{ 0x3C, 0x7C, 0xFF },{ 0x5A, 0x7C, 0xFF },{ 0x78, 0x7C, 0xFF },{ 0x96, 0x7C, 0xFF },{ 0xB4, 0x7C, 0xFF },{ 0xFF, 0x7C, 0xFF },
	{ 0x00, 0xFF, 0xFF },{ 0x1E, 0xFF, 0xFF },{ 0x3C, 0xFF, 0xFF },{ 0x5A, 0xFF, 0xFF },{ 0x78, 0xFF, 0xFF },{ 0x96, 0xFF, 0xFF },{ 0xB4, 0xFF, 0xFF },{ 0xFF, 0xFF, 0xFF },
};



//==============================================================================
// FrameCapturer
//==============================================================================

//struct FrameCapturer::GifContext
//{
//	jo_gif_t	gif;
//	ByteBuffer	framePixels;
//	Size		frameSize;
//	int			frameCount = 0;
//};

//------------------------------------------------------------------------------
FrameCapturerPtr FrameCapturer::Create()
{
	auto ptr = FrameCapturerPtr::MakeRef();
	ptr->Initialize(GraphicsManager::GetInstance());
	return ptr;
}

//------------------------------------------------------------------------------
FrameCapturer::FrameCapturer()
	: m_manager(nullptr)
	, m_capturerTarget(nullptr)
	, m_requestedState(State::Stoped)
	, m_gifContext(nullptr)
	, m_currentState(State::Stoped)
	, m_lastTick(0)
{
}

//------------------------------------------------------------------------------
FrameCapturer::~FrameCapturer()
{
	LN_SAFE_RELEASE(m_capturerTarget);

	//if (m_gifContext != nullptr)
	//{
	//	jo_gif_write_footer(m_stream.get(), &m_gifContext->gif);
	//	jo_gif_end(&m_gifContext->gif);
	//}
	LN_SAFE_DELETE(m_gifContext);
}

//------------------------------------------------------------------------------
void FrameCapturer::Initialize(GraphicsManager* manager)
{
	m_manager = manager;
	m_gifContext = LN_NEW GifContext;
}

//------------------------------------------------------------------------------
void FrameCapturer::SetCapturerTarget(RenderTarget* renderTarget)
{
	LN_REFOBJ_SET(m_capturerTarget, renderTarget);
}

//------------------------------------------------------------------------------
void FrameCapturer::StartRecording()
{
	m_requestedState = State::Recording;
}

//------------------------------------------------------------------------------
void FrameCapturer::StopRecording()
{
	m_requestedState = State::Stoped;
}

//------------------------------------------------------------------------------
void FrameCapturer::Record()
{
	LN_CHECK_STATE(m_capturerTarget != nullptr);


	RefPtr<FrameCapturer> fc = this;
	Driver::ITexture* target = m_capturerTarget->GetDeviceObject();
	State newState = m_requestedState;

	LN_ENQUEUE_RENDER_COMMAND_3(
		FrameCapturer_Record, m_manager,
		RefPtr<FrameCapturer>, fc,
		RefPtr<Driver::ITexture>, target,
		State, newState,
		{
			fc->RecordCommand(target, newState);
		});
}

//------------------------------------------------------------------------------
void FrameCapturer::RecordCommand(Driver::ITexture* target, State newState)
{
	// 録画状態の変化確認
	if (newState != m_currentState)
	{
		if (newState == State::Stoped)
		{
			//jo_gif_write_footer(m_stream.get(), &m_gifContext->gif);
			//jo_gif_end(&m_gifContext->gif);
			//m_stream = nullptr;//.SafeRelease();
			m_gifContext->Close();
		}
		else if (newState == State::Recording)
		{
			PathNameA filePath("FrameCapturer.gif");
			m_gifContext->Open(filePath, target->GetSize());
			//m_stream = std::make_shared<BinaryWriter>(FileStream::Create(filePath, FileOpenMode::Write | FileOpenMode::Truncate));//.Attach(LN_NEW BinaryWriter(FileStream::Create(filePath, FileOpenMode::Write | FileOpenMode::Truncate)), false);

			//const Size& size = target->GetSize();
			//m_gifContext->gif = jo_gif_start(size.width, size.height, 0, 256);
			//m_gifContext->framePixels.Resize(size.width * size.height * 4);	// 4 component. RGBX format, where X is unused
			//m_gifContext->frameSize = size;
			m_lastTick = 0;

			//jo_gif_write_header(m_stream.get(), &m_gifContext->gif);
		}
		m_currentState = newState;
	}

	// 録画
	if (m_currentState == State::Recording)
	{
		struct RGBX
		{
			byte_t r, g, b, x;
		};


		// 差分時間計算
		uint64_t deltaTick = 0;
		uint64_t curTick = Environment::GetTickCount();
		if (m_lastTick != 0) deltaTick = curTick - m_lastTick;

		// RenderTarget の内容を読み取る
		//ScopedTextureLock lock(target);
		Bitmap* bmp = target->Lock();	//TODO: Scoped
		m_gifContext->AddFrame(bmp, deltaTick / 10);	// milliseconds to centi-seconds
		//const Size& bmpSize = bmp->GetSize();
		//RGBX* frame = (RGBX*)m_gifContext->framePixels.GetData();
		//for (int y = 0; y < m_gifContext->frameSize.height; ++y)
		//{
		//	for (int x = 0; x < m_gifContext->frameSize.width; ++x)
		//	{
		//		RGBX* p = &frame[y * m_gifContext->frameSize.width + x];
		//		if (x >= bmpSize.width || y >= bmpSize.height)
		//		{
		//			p->r = 0x00;
		//			p->g = 0x00;
		//			p->b = 0x00;
		//			p->x = 0xFF;
		//		}
		//		else
		//		{
		//			Color c = bmp->GetPixel(x, y);
		//			p->r = c.r;
		//			p->g = c.g;
		//			p->b = c.b;
		//			p->x = 0xFF;
		//		}
		//	}
		//}
		target->Unlock();


		// 書き込み
		//bool local_palette = (m_gifContext->frameCount == 0);
		//jo_gif_frame_t gifFrame;
		//jo_gif_frame(&m_gifContext->gif, &gifFrame, (unsigned char*)frame, m_gifContext->frameCount, local_palette);
		////jo_gif_frame(&m_gifContext->gif, (unsigned char*)frame, deltaTick / 10, false);	// milliseconds to centi-seconds
  //      jo_gif_write_frame(m_stream.get(), &m_gifContext->gif, &gifFrame, nullptr, m_gifContext->frameCount++, deltaTick / 10);

		m_lastTick = curTick;
	}
}

LN_NAMESPACE_GRAPHICS_END
LN_NAMESPACE_END
